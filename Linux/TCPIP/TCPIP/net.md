## 网络

#### TCP/IP协议族

* 简介

```c++
/*
1. TCP/IP协议族是一个分层的, 多协议的通信体系
2. TCP/IP自底向上分为数据链路层, 网络层, 传输层, 应用层
*/
```

![image-20200514161113801](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20200514161113801.png)



* 分层

  * 数据链路层

  ```c++
  /*
  作用:
  1. 数据链路层是负责相邻节点的数据传输
  2. 数据链路层实现了网卡接口的网络驱动程序, 来处理数据在物理媒介上的传输, 屏蔽了底层的细节
  
  数据链路层需要解决的问题:
  1. 封装成帧:
    网络层传输的数据, 在链路层需要加上帧头和帧尾称为数据帧
  2. 透明传输
    在进行网络传输的过程中, 数据帧的数据可能会与检验数据帧的起始和结束的首尾标记冲突,
    数据可能只接收了一部分
    透明传输就是在链路层中检查数据, 如果有与首尾标记冲突的数据, 在冲突数据之前插入符号
    标记, 来表明这是数据, 而不是首尾标记. 在接收方将符号删除.
  3. 差错检测
    在进行网络传输的过程中, 数据帧是否完整需要进行CRC校验.                             它的原理判断帧检验序列, 先由数据与seq相除求余得到帧检验序列FCS,  将FCS封装到数据帧中,
    接收方将数据与FCS相除, 如果余数为0则代表数据正常, 如果余数不为0代表数据有差错
  */
  
  /*
  常见的协议:
  ARP:
  1. ARP协议负责IP地址到物理地址的转换
  2. 因为数据链路层是负责相邻节点的数据传输, 因此必须要知道相邻节点的MAC地址
  通过发送一个arp广播数据包到局域网, 局域网内的主机都可以收到, 但只有与目标IP相符的主机才会应答, 并携带上本机的MAC地址
  
  ARP缓存:
  ARP协议维护一个高速缓存, 这个缓存记录了IP->MAC的映射, 避免重复的ARP广播请求
  
  RARP:
  1. RARP协议负责物理地址到IP地址的转换
  2. RARP协议只用于网络上的某些无盘工作站, 无盘工作站没有响应的存储设备, 无法记住自己的IP地址, 可以通过网卡驱动程序发送带有MAC地址的RARP请求来向存储服务器查询自己的IP地址
  */
  ```

  ![image-20200514201046395](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20200514201046395.png)

  ```shell
  # 常用指令
  # 查看arp缓存
  $ sudo arp -a
  # del arp缓存映射
  $ sudo arp -d IP
  # set arp缓存映射
  $ sudo arp -s IP MAC
  ```

  

  * 网络层

  ```c++
  /*
  作用:
  1. 网络层负责路由选择和数据转发
  
  网络层需要解决的问题:
  1. 封装成包    
    在网络层需要将源IP地址与目的IP地址等信息进行封装    
  2. 数据分片    
    因为数据帧限制上层的数据包大小不能超过1500,     
    而网络层数据包最大为65535, 如果数据包大小大于1500字节, 需要进行分片,    
    将数据包分成多个小数据包, 在头部记录好数据包分组与偏移量等信息.    
    因此在网络层数据包大小最大为1500字节, 去掉头部, 最大数据为1480字节    
  3. 差错检测    
    通过校验和来验证头部是否正常, 通过反码求和算法,     
    将头部按16平均分开进行按位取反求和得到校验和,    
    接收方依然将头部按16位平均分开与校验和进行按位取反求和, 如果结果取反为0则正常, 否则丢弃
  */
  
  /*
  常见的协议:
  IP:
  1. IP协议根据数据目的IP来选择合适的路由, 一般说实现了路由选择的协议都是IP协议
  
  ICMP(不是严格意义上的网络层协议, 因为它是基于IP协议的):
  1. ICMP协议负责检测网络连接
  2. 比如说ping这个应用程序就是基于ICMP协议的
  */
  ```

  ![](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20200514194555834.png)

  8位类型: ICMP报文的类型, 分为差错报文和查询报文
  8位代码: ICMP类型的细分, 比如说重定向报文, 0表示网络重定向, 1表示本机重定向

  

  * 传输层

  ```c++
  /*
  作用:
  1. 传输层主要负责端与端之间的通信
  
  常见的协议
  TCP:
  1. 面向连接, 可靠的, 面向字节流
  
  UDP:
  1. 无连接, 不可靠, 面向数据包
  */
  ```

  

  * 应用层

  ```c++
  /*
  作用:
  1. 应用层主要负责应用程序逻辑的处理
  
  常见的协议:
  ping: 基于ICMP协议, 用来检测网络连接
  telnet: 基于TCP协议, 可以作为客户端来连接服务器
  ospf: 基于IP协议, 是一种动态路由协议, 通过网络带宽来进行路由选择
  RIP: 基于UDP协议, 是一种动态路由协议, 通过路由跳数来进行路由选择
  DNS: 基于UDP协议, 负责域名与IP地址的转换
  */
  ```

* 封装与分用

```c++
/*
封装: 就是数据自顶而下, 不断封装最后发送的网络中
分用: 就是数据自底向上, 不断解析分发给指定的协议或应用
*/
```

![image-20200514203541763](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20200514203541763.png)

![image-20200514203558934](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20200514203558934.png)

#### 数据链路层协议

* 特点

```c++
/*
负责相邻设备间的数据帧传输
*/
```

![image-20200924222125414](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20200924222125414.png)                                   

  1. 48位源/目的MAC地址: 描述源/目的网卡的硬件地址, uint8_t[6]
    2. 上层协议类型: 描述描述上层协议类型(IP/ARP/RARP), 用于数据分用
  1. 数据                 
    以太网数据帧中数据的大小范围一般为46~1500, 之所谓为46是由于在链路层中需要通过最少数据来进行冲突检测, 这个最小数据为64字节, 减去帧头帧尾的18字节大小, 数据的最小值为46字节
  MTU: 最大传输单元. 限制了上层封装之后的数据                                                                         
  1. CRC校验和: 检验数据的一致性

* CSMA/CD协议

```
载波监听与冲突检测的多路访问协议, 以太网可以说是基于CSMA/CD协议的局域网技术
1. 多路访问(多点接入): 
  多个主机在同一局域网内进行数据传输
2. 载波监听与冲突检测:
  在局域网内, 多个主机可能会同时发送数据到网络中, 可能会发生冲突.
  载波监听与冲突检测就是来解决数据冲突的问题
  一台主机在发送数据时, 先判断是否发生数据冲突, 如果在发送了一定的数据量之后没有检测到
  冲突, 那么说明数据发送是安全的, 这个数据量在100mb/s带宽下一般为64字节, 也就是说如果
  发送了64字节还没有检测到冲突, 那么数据就是安全的;
  如果发生数据冲突, 那么接收到冲突的主机会停止发送数据, 等待随机时间后再进行数据的发送.                                               
  二进制指数退避算法: 
  max_wait=2^k, k代表重传的次数, k最大取值为10, 如果重传的次数超过16次了, 那么传送失败.
  wait = [1,maxwait]内的随机时间
```

* MTU对传输层的影响

```
MSS: 最大报文段长度(TCP数据报数据部分)
MTU: 最大传输单元(数据链路层数据部分)

UDP: UDP在传输层封装数据报的时候, 数据的最大长度不受MTU的影响, 
  因此如果封装之后的数据报长度大于MTU, 那么会在网络层进行分片.
  分片会存在一定的危险, 如果任意分片丢失整个数据报会被丢弃, 分片越多, 危险越大
TCP: TCP在传输层封装数据报的时候, 数据的最大长度受MTU的影响
  双方会根据MTU协商MSS, 因此封装后的数据报长度不会大于MTU
  从而也不会在网络层进行分片
```



#### IP协议

* 特点

```c++
/*
1. IP协议通过目的IP来选择合适的路由, 一般说凡是实现了路由选择的协议都可称为IP协议
2. IP协议只是为了转发数据, 因此它是无连接, 不可靠, 无状态

优势:
1. 简单
2. 高效

应用:
1. 比如说HTTP服务器, 多次页面请求之间是毫无关联的
```

![image-20200514211610813](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20200514211610813.png)

1. 4位版本号: IPV4或IPV6

2. 4位头部长度: 单位是4字节, 头部长度的范围是20-60字节

3. 8位服务类型: IP协议为应用程序提供的服务, 同时只能添加一个服务, 比如说最小延迟(telnet ssh), 最大吞吐量(ftp)

4. 16位总长度: 来限制IP数据包的最大长度, 但是由于数据链路层中MTU的影响, IP数据包如果超过MTU的大小是需要进行分片的

5. 16位标识: 用来标识分片数据包是属于那个数据的, 因此同一数据的所有分片的标识相同

6. 3位标志: 标识分片属性

7. 13位片偏移: 单位是8, 用来标识分片数据包在原数据中的位置, 除了最后一个分片, 其他分片数据的大小必须是8的整数倍

8. 8位生存时间: TTL限制了数据包在网络中存留的时间

9. 8位协议: 指上层封装的协议, ICMP为1, TCP为6, UDP为17

10. 16位头部校验和: 对端进行CRC校验

11. 32位源/目的IP

* 路由选择与IP转发

![image-20200514230818482](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20200514230818482.png)



```c++
/*
IP模块的工作流程:
1. 数据到达网络层
2. 先进行CRC校验, 如果校验不通过则直接丢弃
3. 解析IP头部信息, 如果目的IP与本机IP相同则向上继续分用, 否则交给数据包转发子模块
4. 数据包转发子模块判断转发权限, 如果不能转发则直接丢弃, 否则转发给下一跳路由器
5. 路由器根据路由表来计算下一条路由, 将数据交给输出队列一并转发
*/
```

```c++
/*
路由选择:
1. 查询路由表, 找与目的IP相同的主机, 如果没找到那么进入第2步
2. 查询路由表, 找与目的IP相同网络号的主机, 如果没找到进入第3步
3. 下一跳转发给网关

IP转发:
1. 解析头部信息, 检查TTL, 如果为0则直接丢弃
2. 检查目的IP是否与本机IP相符, 如果不相符并且严格按照路由选择则直接丢弃
3. 如果有必要, 给源端发送一个ICMP重定向报文来更新路由表(一般是更新缓存), 可能会分片
4. TTL减1
*/   
```



* 常用命令

```shell
# tcpdump抓取ICMP报文
# -v: 显示详细信息
sudo tcpdump -i ens33 -ntv icmp

# ping向服务器发送请求数据包
# -s: 指定数据包的大小, 来强制分片
ping server -s 1473

# 查看主机是否允许IP转发, 0表示不允许, 1表示允许
# 一般主机只负责收发数据
cat /proc/sys/net/ipv4/ip_forward

# 查看主机是否允许发送ICMP重定向
# 一般主机只接收ICMP重定向报文, 路由器只发送ICMP重定向报文
cat /proc/sys/net/ipv4/conf/all/send_redirects
```



#### TCP协议

* 特点

```c++
/*
1. 面向连接, 可靠传输, 面向字节流
*/
```

![image-20200515134952719](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20200515134952719.png)

1. 16位源/目的端口号: 端口号来标识一个应用程序
2. 32位序号: 数据报的序号,  在三次握手的时候, 双方会协商初始序列号, 序列号与初始序列号的差值来标识该数据报在原数据中的位置
3. 32位确认号: 响应数据报需要的序号, 确认号就是对端需要发送的序号
4. 4位头部长度: 单位是4字节, 头部长度范围20-60字节
5. 6位标志位: 用来标识TCP数据报的种类, ACK(确认报文), SYN(同步报文), FIN(结束报文), RST(复位报文段)
6. 16位窗口大小: 用来标识接收缓冲区最多还能接收多少数据, 进行流量控制
7. 16位校验和: CRC校验
8. 16位紧急指针

* 面向连接

![image-20200515143032285](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20200515143032285.png)

```c++
/*
TIME_WAIT的作用:
1. 保证server端能正常关闭. 如果server发送的FIN请求在网络中丢失了, 那么会进行重传, 此时client就需要进行重传请求的处理
2. 确保由于网络延迟导致的迟来的数据包消失在网络中. 如果新的连接使用同一个IP与port, 那么可能接收到上一次连接迟来的数据包

TIME_WAIT为什么是2MSL(报文段最大生存时间):
一端tcp报文段的最大生存时间为MSL, 2MSL保证2端传输方向上未接收到的TCP报文段消逝在网络中.
*/
```

```c++
/*
tcp连接的建立与关闭:
1. 半关闭状态: tcp的连接是全双工的, 因此允许两端的传输独立关闭. 比如说客户端close告诉服务端数据发送完毕, 但是还可以接收服务器发送的数据
2. 连接超时: tcp连接超时会发起超时重试, 通过查看 /proc/sys/net/ipv4/tcp_syn_retries
默认的超时重试的次数, 重试的规则是1s, 2s, 4s, 8s, 16s ...
*/
```

```c++
/*
RST(复位报文段):
1. 复位报文段来通知对方关闭连接或重新建立连接
2. 复位报文段的win=0, 说明这个报文段不能被回应
产生复位报文段的情况:
1. 访问不存在的端口
2. 异常终止连接, 通过socket选项SO_LINGER来发送复位报文段, 
3. 处理半打开连接, 比如说服务器终止连接, 但是客户端由于网络原因没有收到FIN请求, 客户端处在半打开连接的状态, 此时向服务器发送数据会收到一个复位报文段.
*/
```

* 可靠传输

```c++
/*
1. 重传机制, 超时重传
2. 应答机制, 确认应答
3. 包序管理机制, 序号与确认号
*/
```

* 性能

```c++
/*
1. 流水线机制与滑动窗口
2. 拥塞控制, 来防止由于网络原因导致频繁的丢包现象
慢启动, 拥塞避免, 快速重传, 快速恢复
*/
```

![image-20200924204235290](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20200924204235290.png)

```
慢启动: 试探网络状况, 防止由于网络状况不好导致大量数据包丢失
拥塞避免: 慢启动启动速度不慢, 当到达慢启动门限时改用线性增长的拥塞避免算法

数据包丢失的情况:
1. 定时器溢出, 超时
慢启动门限变为当前CWND窗口大小的一半, 执行慢启动+拥塞避免算法
2. 部分数据包丢失, 接收端收到重复的数据包
前提是定时器没有溢出, 发送端会执行快速重传, 接收端执行快速恢复算法

为什么快速重传要发3次:
根据统计, 接收端收到3次重传数据包大概率是由于数据包丢失了
如果接收端收到较少的重传数据包, 可能是由于数据包乱序到达引起的重传
```



* 常用的命令

```shell
# 查看TCP连接超时后默认重传的最大次数
cat /proc/sys/net/ipv4/tcp_syn_retries

# 查看Linux使用的拥塞控制的算法
cat /proc/sys/net/ipv4/tcp_congestion_control
```



#### socket函数与面向连接的关系

```c++
/*
1. 服务端调用listen, 进入LISTEN状态, 表示服务端可以接收客户端的同步请求了
2. 客户端调用connect, 发送同步请求进入SYN_SENT状态, 此时等待服务端的响应
3. 服务端收到客户端的同步请求并响应后, 将该连接放入未完成连接队列中
4. 客户端收到服务端响应后发送最后一次响应进入ESTABLISHED, connect返回
5. 服务端建立连接后, 将连接放入已完成连接队列中, 也就是说队列中的连接的状态至少已经处在SYN_RCVD状态了
*/
```

