[B-树]:
m阶B-树的性质:
1. 一个节点最多有m个孩子,
除了根节点与叶子节点, 每个节点至少有ceil(m/2)个孩子
2. 一个节点中的关键字最多有m-1个, 
除根节点最少有ceil(m/2)-1个

B-树的插入:
B-树的插入与BST的插入类似, 比当前节点小则往左走, 比当前节点大往右走,
到达叶子节点后, 在指定位置进行插入.
1. 如果插入后, 节点未满, 则插入完毕
2. 如果插入后, 节点满了, 则需要进行分裂,
将中间的值插入到父节点, 该节点分裂成左右孩子,
如果父节点也满了, 则继续向上回溯
(如何判断B-树节点是否满了, 看节点中的关键字, 假设是m阶的B-树
如果m是奇数, 那么关键字为m的时候进行分裂; 如果m为偶数, 关键字为m-1的时候进行分裂,
使得分裂后左右节点中的关键字刚好平衡)

B-树的删除:
B-树的删除与BST的删除类似, 找到要删除的关键字所在的节点.
删除后要判断是否还满足B-树的性质, 无论删除的关键字在哪一个节点,
最终都要落在判断叶子节点是否满足B-树性质上.
1. 如果关键字在叶子节点, 那么直接删除; 如果在非叶子节点上, 那么就从孩子节点借一个(借多的那个)
2. 判断被操作的叶子节点是否满足B-树性质:
叶子节点至少要有ceil(m/2)-1个, 如果不满足, 那么需要调整:
  1) 向相邻兄弟节点借1个, 如果兄弟节点丰满, 从父节点拿1个, 兄弟节点为父节点补上
  2) 如果相邻兄弟节点不丰满, 那么就与父节点进行合并. 使当前叶子节点与兄弟节点, 
  同两者的父节点关键字进行合并

B-树的优势:
1. B-树是一个多阶平衡树, 是一种比AVL更加平衡的树, 因为B-树的所有叶子节点在同一层.
2. B-树应用在文件索引系统中(准确的说应该是B+树),
这是因为B-树解决了在文件索引系统中所关注的2个问题
  1) 更少的磁盘IO. 因为B-树是一种多阶平衡树, 对于300阶的平衡树来说, 
  搜索10000000的数据量最多仅仅花费3次磁盘IO, 相比于AVL树来说有很大的优势
  2) 更快的搜索算法. 因为B-树是一种平衡树, 并且所有的叶子节点在同一层, 是一种
  绝对平衡的树, 搜索的时间复杂度同AVL一样, 是logN, 效率很高

[B+树]:
B+树与B-树的区别:
1. B-树中每一个节点中即存放了索引项(关键字), 同时也存放了数据地址
B+树中非叶子节点只存放索引项, 在叶子节点中存放了所有的索引项及对应的数据地址
这使得B+树的非叶子节点能存更多的索引项, 节点数目相对较少, 磁盘IO次数要比B-要少,
同时数据都在叶子节点, 数据的搜索相对B-树来说更稳定
2. B+树叶子节点被组织成一个有序的链表, 在数据库文件索引系统中, 
对于整表搜索以及区间搜索, 相对来说效率会更高

[B*树]:
B*树与B+树的区别:
1. B*树的节点与兄弟节点连接在一起
2. B*树进行在进行插入的时候, 如果该节点满了, 但是兄弟节点没满,
就将多余的关键字放到兄弟节点上
如果兄弟节点也满了, 那么在分裂生成新节点的时候,
在分裂节点拿1/3的数据到新节点, 再在兄弟节点中拿1/3的数据到新节点
这样使得B*树中节点的空间利用率要比B+树要高, 
分裂产生新节点的概率要小, 节点的数量要比B+树少, 磁盘IO的次数要比B+树少

