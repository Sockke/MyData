[临界资源与临界区]:
1. 临界资源: 同一时间只能一个线程操作的共享资源
2. 临界区: 存在临界资源的代码段

[死锁]:
1. 什么是死锁?
死锁就是当多个线程执行过程中, 由于资源竞争或彼此通信而造成的阻塞现象
2. 死锁产生的4个必要条件?(必须同时满足)
  1) 互斥: 我加锁之后, 别人不能再加锁
  2) 不可剥夺: 我加的锁, 别人不能解锁
  3) 请求与保持: 我请求别的锁, 同时不释放自己的锁
  4) 环路等待: 双方由于请求保持而陷入阻塞

[互斥]:
1. 什么是互斥?
保证在多线程环境下, 对临界资源操作的安全性

[同步]:
1. 什么是同步?
保证在多线程环境下, 对临界资源操作的时序合理性
2. 线程同步的方式
  互斥量: 一般主要是保证互斥的, 只能实现简单的同步
    1. 定义互斥锁:
    pthread_mutex_t mtx;
    2. 初始化互斥锁:
    pthread_mutex_init(&mtx, NULL);
    3. 加锁, 解锁
    pthread_mutex_lock(&mtx);
    pthread_mutex_unlock(&mtx);
    4. 销毁锁
    pthread_mutex_destroy(&mtx)
  条件变量: 配合互斥锁, 基于等待与唤醒来实现同步
  它的原理就是, 条件变量本质上是一个标识, 当调用pthread_cond_wait的时候, 
  不仅要修改标识, 同时还要完成2步重要的操作, 将线程放到等待队列中, 
  释放锁. (调用pthread_cond_wait必须保证线程已经加锁)
  这是因为修改标识与将线程放到等待队列不是是原子操作, 
  可能会造成死锁, 因此条件变量需要搭配互斥锁来保证这个过程是原子的.
    1. 定义条件变量:
    pthread_cond_t cond;
    2. 初始化条件变量:
    pthread_cond_init(&cond, NULL);
    3. 等待与唤醒:
    (进入等待队列, 然后释放锁, 这2步操作封装为原子操作
    当条件满足时, 进入就绪队列获取锁)
    pthread_cond_wait(&cond, &mtx);
    pthread_cond_timewait(&cond, &mtx, &timeout); // 即使等待
    pthread_cond_signal(&cond);  // 唤醒一个
    pthread_cond_broadcast(&cond);  // 唤醒所有
    4. 销毁条件变量
    pthread_cond_destroy(&cond);

  信号量: 通过计数器来控制线程的访问, 同样是基于等待与唤醒保证同步
    1. 定义信号量变量:
    sem_t sem;
    2. 信号量的初始化:
    sem_init(&sem, 0, 0);  // 第一个0: 表示同一进程之间, 第二个0: 信号量初始值
    3. 等待与唤醒
    (先判断计数器的值, 如果大于0, 则减1继续执行,如果等于0, 则进入等待队列
    当计数大于0, 进入就绪队列, 运行时减1继续执行, 这些都是原子操作)
    sem_wait(&sem);
    sem_trywait(&sem); // 非阻塞等待
    sem_timedwait(&sem, &timeout); // 计时等待
    sem_post(&sem); // 计数器加1
    4. 销毁信号量
    sem_destroy(&sem);

[多线程的缺点]:
1. 成本
  有些情况下可能不需要使用多线程, 串行化就可以解决.
  这种情况下使用多线程会增加开发成本
  多线程要考虑线程安全, 死锁等问题, 难以控制
2. 性能
  多线程不一定性能就高. 
  首先每个线程有独立的栈空间, 系统资源占用过多会整体影响性能
  其次过多的上下文切换也会影响性能


