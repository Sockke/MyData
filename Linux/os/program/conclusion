[构建程序的过程]:

  [预处理]:
  1. 处理以#开头的一些代码, 比如说#include头文件的展开, 
  #define宏定义的替换, 预处理等, 处理#pragma, 这是编译时期需要处理的
  2. 把注释给删除

  [编译]:
  1. 将源代码转换成汇编代码
  2. 这个过程包括语法, 词法的分析, 源代码级别的优化, 目标代码级别优化等

  [汇编]:
  1. 将汇编代码转换成机器指令生成目标文件

  [链接]:
  (静态链接):
  1. 链接目标文件以及库文件生成可执行文件
  2. 包括2个步骤:
    1) 符号解析
    这里的符号主要是指在编译时期为全局变量, 静态变量, 函数生成的符号,
    符号解析就是扫描所有的.o文件, 为每个符号的引用找到对应的符号定义.
    如果说只有符号引用, 没有符号定义, 会产生未定位行为
    如果说相同符号有多处定义, 会产生重定义
    2) 重定位
    重定位就是合并所有.o文件中的各个段, 为每个符号分配运行时的地址.
    

[静态库]:
  静态链接时, 链接的是静态库, 静态库是有各个.o文件包装成一种特殊的库文件. 
  .o文件中包含了一些函数的定义, 在头文件中包含了一些声明.
  在进行静态链接的时候, 不会将整个静态库拷贝一份生成可执行文件, 
  而是将程序中引用的.o模块拷贝生成可执行文件(引用的.o模块可能还依赖其他的.o模块)

  静态库的好处?
  1. 将一些功能代码的实现封装到一个个的.o模块中, 将声明放到头文件中,
  方便程序员的调用, 在链接时只链接引用部分, 减少了磁盘和内存的压力
  2. 相比于动态库来说, 可移植性强, 加载和运行速度快
    
  静态库的使用?
  1. 将一些功能代码的实现封装到.o模块中, 
  gcc -c add.c -o add.o   // 生成.o文件
  ar rcs libadd.a add.o   // 生成静态库
  2. 将声明放到头文件中
  add.h
  3. 通过静态链接生成可执行文件
  gcc -static main.c -o main -L. -ladd  // -L指定静态库的位置, -l指定链接的静态库

[动态库]:
  动态链接与静态链接有2大不同:
  1. 链接的时期不同, 静态链接在链接时期, 就完成了符号解析与重定位的工作, 
  动态链接在链接时期只做了符号解析, 具体的重定位工作是在装载时期甚至是运行时期才完成的
  2. 链接的方式不同, 静态链接是将所有的符号引用所在的.o模块合并到可执行程序当中,
  如果多个进程引用了同一个.o模块, 那么每个进程中都有一份拷贝
  但是动态链接在链接时期不将符号所在的.o模块合并, 而是将符号引用记录在全局符号表中,
  在装载时期, 对引用动态库的符号进行重定位, 在运行过程中调用动态库中的函数, 
  如果该动态库被其他进程加载了, 只需要建立虚拟地址与物理地址的映射; 如果没有加载,
  则将动态库加载到内存中. 如果多个进程引用了同一个动态库, 那么所有进程中只有一份拷贝.

  fPIC?
  产生地址无关代码.
  因为动态库是多个进程共享的, 如果所共享的数据或指令采用绝对地址的引用, 那么可能会产生
  地址冲突的问题. -fPIC就是在编译时期产生的.o文件是地址无关的代码, 假设对动态库的引用采用相对地址, 
  可以在虚拟地址的任意位置进行排布.
  也就是说对于动态库的共享, 多个进程映射在虚拟地址空间的位置可能不同, 但是
  映射在物理页上的位置相同

  动态库的优势?
  1. 节省了磁盘和内存的资源. 多个进程引用同一个动态库, 在磁盘和内存中只有一份拷贝
  2. 有利于后期的扩展与更新. 只需要更新动态库即可, 不需要像静态库那样重新链接.

[装载]:
  装载就是通过页映射的方式将可执行程序从磁盘加载到内存中
  1. 创建虚拟地址空间. 在执行可执行文件时, 系统会调用fork()创建进程, 然后通过execve来
  执行可执行文件, 在创建进程的过程中为进程创建了独立的进程地址空间, 但是还没有建立
  进程地址空间与物理内存的映射, 仅仅是将ELF文件的头部信息拷贝到内存
  2. 建立虚拟地址空间与可执行文件的映射. 这是当发生缺页的时候, 缺页处理程序能够
  知道从可执行程序的哪个位置将数据加载到物理内存中
  3. 加载器跳转到main程序入口, 开始执行程序

[虚拟地址空间]:
  虚拟地址又称为线性地址, 虚拟地址与页映射是虚拟存储器管理内存的方式
  [虚拟地址到物理地址的映射]:
  以x86为例, 地址长度为32位
  1. 高10位作为页目录表的索引. cpu拿到虚拟地址, 交给mmu, mmu先访问页目录表基址寄存器
  找到页目录表, 根据虚拟地址高10位的索引, 找到虚拟页表的地址.
  2. 中间10位为虚拟页表的索引. 根据中间10为的虚拟页表的索引找到指定的物理页表.
  3. 低12位为物理页表偏移量. 根据低12位的物理页表偏移量来最终确定物理地址的位置.
  [缺页]:
  1. 正常缺页. 对合法的虚拟地址进行操作, 当发现改虚拟地址还没有建立与物理地址的映射, 
  发生缺页, 执行缺页处理程序, 根据虚拟地址与可执行文件的映射, 将指定的数据加载到
  物理内存中, 并建立虚拟地址与物理地址的映射. 此时重新进行操作.
  2. 不正常缺页. 比如说段错误, 保护异常. 段错误就是指访问一个不存在的虚拟地址.
  保护异常就是访问一个受保护的虚拟地址
  [多级映射的好处]:
  1. 防止浪费内存空间. 因为如果建立1级映射, 就需要通过一张页表来映射整个内存,
  一个物理页4k, 那么需要2^20个物理页, 也就是说这张页表需要有2^20个表项,
  每个表项为4字节, 那么这个页表需要4M的大小.
  每个进程都要维护一个4M的页表, 很显然是对内存的极大浪费
  2. 按需分配. 多级页表实现了按需分配的功能, 通过多级映射, 上级的页表的表项不直接
  存放物理页地址了, 而是存放下一张页表的地址, 这样将需要映射的物理内存局部独立化,
  可以按需进行页表的分配, 减少了内存的浪费
  [TLB]:
  页表条目缓存机制, 提高线性地址到物理地址的转换效率
  1. 提高地址翻译的效率. 因为每次查看页表条目的时候都要访问1次内存, 转换成物理地址之后
  还要访问1次内存. 总共需要访问2次内存, 这样效率是不高的.
  TLB就是存放页表条目的缓存, 这样mmu查看页表条目的时候先访问TLB, 可以少访问1次内存.

  [虚拟地址的描述和组织]:
  1. PCB中的mm_struct结构体描述了进程地址空间的信息
  其中的mmap是一个链表, 他将很多虚拟内存区域链接在一起
  每个虚拟内存区域包括vm_start, vm_end, next等信息
  2. pdg描述了页目录表的地址
