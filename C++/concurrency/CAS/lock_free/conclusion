什么是无锁数据结构:
能够允许多个线程并发的去访问的数据结构
比如说, 无锁栈, 无锁队列, 在boost库中提供了相应的无锁数据结构

无锁数据结构实现需要注意的点:
1. 内存顺序. 在设计无锁数据结构的时候, 因为是基于原子操作,
首先要考虑内存顺序, 默认是memory_order_seq_cst强顺序, 
如果要考虑数据结构的优化和性能, 可以选择性的松懈内存顺序
2. 无锁内存的回收. 当需要释放的结点被其他线程也引用的时候, 
就不能直接进行释放, 否则在进行compare_and_swap的时候会导致垂悬指针引起未定义行为.
最好的情况是通过GC来进行管理, 但是C++中未实现GC, 需要手动进行设计,
原理就是维护一个待释放的队列, 通过引用计数来判断, 当没有其他线程进行
引用时, 再进行结点的释放
3. ABA问题. 这是受原子操作的原理所限制, 存在一种情况, 当该线程所期待引用的结点
被其他线程进行释放以及添加后不仅值没有改变, 地址也没有改变, 但是这已经不是
原先所期待引用的值, 当进行compare_and_swap时会出现"假成功".
可以同过对引用变量加一个计数器, 当这个变量被修改时计数加一, 这样可以解决ABA问题
4. 忙等待问题. 因为compare_and_swap是一种忙等待机制, 如果说像无锁队列这种, 执行入队操作
的线程必须等待其他执行入队操作的线程完成后, 才能执行. 那么频繁的循环会导致cpu资源的浪费.
解决的方案可以使忙等待的线程进行短暂的睡眠或者先去完成其他未完成的任务
