[线程管理]:
  [启动线程]:
    std::thread t(func);
    func只要是可调用类型(callable)即可, 比如说普通函数, 类的operator()函数

    解析歧义:
      std::thread t(func());
      对于向thread中传入一个临时变量, 会出现解析歧义的情况
      此时不会启动一个新线程, 而是将其视为返回类型为std::thread的函数声明

    lambda表达式快速实现简单任务的并发:
    std::thread t([](){
      std::cout << "hehe" << std::endl;
    });

  [线程分离]:
    t.detach() --- DETACHED
    线程分离后, 会挂起到后台运行, 运行结束后系统会自动回收其资源

    在分离线程中传入临时变量的指针或引用:
      如果在分离线程结束之前, 临时变量提前被销毁, 分离线程对参数的使用会出现不可预期的结果
      (比如说参数传递后存在隐式转换, 在转换之前, 该参数已被销毁: 可以将参数显示转换后再传入)
      可以通过值传递, 或者在临时变量被销毁之前分离线程退出
      *可以通过join来进行阻塞等待线程

  [线程等待]:
    t.join() --- JOINABLE
    阻塞等待线程退出, 然后回收线程资源

    在异常情况下等待线程:
      如果在抛出异常之前, 线程没有正常退出, 则程序会触发terminal()异常而终止
      可以通过在可能抛出异常的地方之前进行join, 但是这会影响线程的作用域
      *可以通过RAII来实现线程的等待

  [线程参数的传入]:
    std::thread默认是将传递的参数以拷贝的形式复制到新线程空间
    当需要以引用的方式传入的时候, 需要通过std::ref/std::cref来模拟引用传递
    在非模板情况下, ref无法实现引用传递, 只有模板自动推导类型时, ref能通过
    包装类型reference_wrapper来代替参数类型, 最后隐式转换为引用类型

  [线程所有权的转移]:
    线程不可以进行copy, 但是可以通过move转移所有权
    被转移所有权的线程, 自动被系统销毁, 不能再进行detach或join
    线程所有权的转移可以使得线程的管理和控制更加灵活

  [线程标识]:
    t.get_id()  :获取指定线程id
    std::this_thread::get_id()  :获取当前线程id
    线程标识可以关联线程, 不需要再传入标识参数
