常见的环结构: 布尔环(异或), 模运算

[关于有符号数和无符号数]:
无符号数会引发负溢的问题, 其他语言设计者认为无符号数的弊大于利,
比如说java只支持有符号数
但是无符号数在某些场景下还是很有意义的, 比如说布尔标记, 地址表示等


---[整数运算]---
[无符号加法]:
  // 无符号加法溢出时, 将大于n所有位截断
  没溢出: x + y = x + y (x + y < 2^n)
  溢出: x + y = x + y - 2^n (2^n <= x + y <= 2^(n+1) - 2)

**[模数加法]: 对于两个数之和求模的运算, 保证了封闭性 --- 比如说两个8位整数相加是模256
  这也是上述所谓位截断的另一种思想 --- 模数加法, 溢出位必定是2^n的倍数
  x + y = (x + y) % 2^n
  对于一个无符号整数的加法逆元: 
    -x = 0 (x = 0)
    -x = 2^n - x (x > 0)

[有符号加法(补码加法)]: 
  // 有符号加法溢出时, 在补码中将大于n所有位截断 
  正溢出: x + y - 2^n (x + y >= 2^(n-1))
  正常: x + y (-2^(n-1) <= x + y < 2^(n-1))
  负溢出: x + y + 2^n (x + y < -2^(n-1))

[无符号乘法与补码乘法]:
  无符号乘法与无符号加法的思想是一样的, 位截断或模数加法
  x * y = (x * y) % 2^n
  补码乘法与补码加法也是类似的, 基于补码的位截断或模数加法

**[移位优化]: 在大多数的机器上, 整数乘法指令是相当慢的, 需要12或更多的时钟周期
而其他整数运算比如加法, 减法, 位级运算和移位只需要1个始终周期, 
因此编译器试着用移位和加法组合来代替乘法运算, 比如说a*3 = (a << 1) + a

[乘以2的幂]:
  移位+位截断
[除以2的幂]:
  (x<0 ? (x+(1<<k)-1)) : x) >> k
  因为整数相除会存在舍入问题, 因此简单的移位可能会造成错误, 比如说被除数为负数时其补码的移位
  是不准确的, 需要加上一个偏置值(我也搞不懂咋推理的)

[浮点数]: 浮点数是遵循IEEE标准
  浮点数包括三个划分: 符号位+指数位+有效数位(小数位)
  C语言中浮点数的划分: float(1, 8, 23), double(1, 11, 52)

  [规格化值]: 指数位不全为0, 也不全为1
    指数的值 = e - Bias --- e为指数位上的值, Bias(偏置值) = 2^k - 1
    Bias使得指数的值控制在 1-Bias ~ (2^k-1)-Bias  --- 比如说单精度:-126~127 双精度:-1022~1023
    有效数的值 = 1 + f --- 有效数的第一位隐式为1
  [非规格化值]: 指数位全为0
    指数的值 = 1 - Bias --- 为固定值, 即最小的指数值
    有效数的值 = f
    非格式化的值可以用来表示非常接近于0的值
    
