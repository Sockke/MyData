## SGI STL

### 简介
sgi stl是stl中最为出色的一个版本, sgi默认使用二级空间配置器来管理内存. 
以vector为例, 默认使用的是二级空间配置器.
1. 对于对象的构造与析构, 是通过全局的construct与destroy来实现的, 
construct底层使用的依然是定位new, destroy使用的依然是调用对象的析构函数.
2. 对于对象内存的开辟与释放, 通过allocate与deallocate来实现的,
allocate底层对于大于128字节的内存依然是malloc来申请, 对于小于等于128字节的内存向内存池来申请;
deallocate底层对于大于128字节的内存依然通过free来释放, 对于小于等于128字节的内存归还给内存池.
3. 内存池的结构类似于链式hash的结构, 一维数组中, 每个元素挂了一个静态链表

### 优势
1. 解决了频繁申请小块内存引起的内存碎片的问题.
2. 解决了频繁调用malloc引起的brk, mmap等系统调用带来的消耗问题.

### 分配策略
1. 如果大于128字节, 直接通过malloc来申请内存; 否则向内存池来申请内存.
2. 比如说我要申请一个24字节的内存
  1. 如果对应空闲链表中有内存块, 那么就分配出去.
  2. 如果没有, 先查看备用内存, 如果有那么从备用内存取出一个内存块分配出去.
  3. 如果备用内存块不够分配24字节, 先将这块较小的备用内存挂在其他的空闲链表上;
  然后通过malloc来分配足够大的内存, 分成空闲内存与备用内存; 从空闲内存中取出一个内存块分配出去.
  4. malloc可能会分配失败

### 分配失败
1. 内存池中如果malloc分配失败, 先搜索较大的其他的空闲链表, 取一个内存块分配出去.
2. 如果较大的空闲链表中也没有, 那么调用oom_malloc; 用户可以预设一个回调函数, 当malloc分配失败时,
会自动调用这个回调函数, 完成一些内存的释放, 然后重新尝试malloc, 这是一个循环的过程. 如果用户没有
预设回调, 那么默认是抛出bad_alloc异常.
  
