8086: 第一代单芯片, 16位微处理器之一
i386: 体系结构扩展到32位, 增加了平面寻址模式, 采用IA32架构
  Linux和最近版本的Windows系列操作系统都是使用这种模式的
  (将整个存储空间看做一个大的字节数组)

Intel的指令集: IA32:"Intel32位体系结构", 这个处理器系列也成为x86
在IA32体系上, 内存地址概念分为: 逻辑地址, 线性地址, 物理地址
  在 IA32 x86_64 中, ebp, esp 扩展为 rbp, rsp

[gcc -O2 main.c -o main的描述]:
  用O2(二级优化)是在优化性能和使用方便之间最好的妥协, 
  因为虽然优化级别越高, 运行速度越快, 但是也会影响编译时间

  将源代码转化成可执行代码: 首先C预处理器扩展源代码, 即展开头文件和宏, 
  其次编译器将源代码转化为汇编代码, 然后汇编器将汇编代码转化为二进制目标文件,
  最后链接器将目标文件与标准Unix库函数合并生成可执行代码.

[汇编程序员机器级]:
  程序计数器(PC): 表示将要执行的下一个指令在存储器中的地址
  整数寄存器堆(8个位置): 可以存储整数数据, 地址, 程序状态, 临时数据等
  条件码寄存器: 保存最近执行的算术指令的状态信息, 用来实现控制流的条件变化(if while...)
  浮点寄存器堆(8个位置): 存储浮点数据

[反汇编原理]:
  GAS: GCC产生的汇编代码的格式
  反汇编器生成汇编代码: objdump -d 目标文件/可执行文件
  因为汇编后的代码是二进制格式的, 可以将其看成16进制的字节序列
  IA32的指令长度为0-15个字节, 其与汇编代码具有一一对应关系
  也就是说, 反汇编是根据16进制的字节序列来确定汇编代码的

[数据格式]:
  字: 2字节(从16位扩展而来) ---  双字: 4字节   四字: 8字节
  [操作数指令符]: 
    立即数(常数)+寄存器(寄存器的内容)+存储器(根据有效地址访问某个存储器位置)
  [数据传送指令]:
    mov push pop
  [算术逻辑指令]:
    lea
     计算有效地址:通常的寻址模式: Imm(Eb,Ei,s) = Imm + R[Eb] + R[Ei] * s
     Imm: 立即数偏移   Eb: 基址寄存器    Ei: 变址或索引寄存器    s: 伸缩因子

    inc dec neg not 
    add sub inul xor or and 
    //for (i = 0; i < n; ++i) {
    //    v += i;
    //}
    // 汇编代码中存在: xorl %edx, %edx
    // 这是对%edx寄存器中的值进行清零操作(类似于默认初始化)
    //
    sal(shl) sar shr 
  [控制指令]:
    条件码: CF:进位标志 ZF:零标志 SF:符号标志 OF:溢出标志
    cmp(两数相减) test(两数相与) set(设置条件码)

    jmp (goto) --- jmp(直接跳转)  jmp*(间接跳转)  j(条件跳转)
      当执行PC相关寻址时, PC的值是跳转指令后面那条指令的地址 
      //void cond(int a, int* p) {
      //  if (p && a > 0)
      //    *p += a;
      //}
      //该代码中只有一条if, 但是汇编中有2条分支
      //可以用C模拟汇编控制流来解释:
      //void cond(int a, int* p) {
      //  if (!p) 
      //    goto done;
      //  if (a <= 0)
      //    goto done;
      //  *p += a;
      //  done:
      //}
      //这类似于我们对短路的认识
    [循环]: 汇编中没有相应的指令, 通过条件测试+跳转来实现循环
      大多数汇编器会根据一个循环的do-while形式来产生循环代码, 因此其他的循环会首先
      先转换成do-while的形式的汇编, 再产生机器指令
      
    [switch]: 系统通过跳转表来实现switch
      跳转表是一个数组, 数组中存放了连续的可能跳转的地址(C语言无法实现这种跳转)
      在值的跨度比较小, 且分支比较多时, 这种数据结构的实现相对更加高效
      跨度比较小:
        因为跳转表中的元素是连续的, 跨度越大, 需要存放的元素越多

[过程]:
  [栈帧结构]:
    (栈是基于操作系统而言的, 调用栈是基于进程而言的)
    栈帧是基于调用函数而言的, 它由栈指针和帧指针来确定栈帧的区域

    栈可以保存不能放在寄存器中的其他局部变量:
      比如说存不下的局部变量, 数组或结构变量, 对局部变量取地址&
  [转移控制指令]:
    call  leave ret
  [寄存器使用]:
    寄存器堆的使用是共享的, 为了防止调用函数影响调用之前的值, 对寄存器的操作有一定的规则:
    调用者保存寄存器: 前三个
    被调用者保存寄存器: 接下来的三个
    系统寄存器: 最后两个
    调用者保存和被调用者保存: (caller saved and callee saved)
      这是一种对调用者变量进行保存和恢复的思想, 可以通过将调用者变量保存在
      调用者保存寄存器或被调用者保存寄存器中两种方式
      保存就是将寄存器中的值压栈, 恢复就是将栈中的值出栈
      GCC是通过将调用者变量保存到被调用者保存寄存器中来实现保存和恢复
      因为这种方式减少了入栈和出栈的操作
  [函数调用过程]:
    准备->调用->压栈->出栈->结束
   
    1. 准备: call之前.
      将参数保存起来, 两种方式, 
      vs中直接将参数压栈(调用者栈帧中), 
      gcc将其保存到寄存器中(被调用者寄存器)
    2. 调用: call.
      将下一条指令的地址压栈
      进入被调用的函数
    3. 压栈
      push ebp 将调用者的帧指针压栈
      mov ebp, esp使帧指针指向栈指针
      sub esp, 0x20 为被调用函数开辟栈帧空间
      (vs还会做一个初始化工作, rep stos循环将栈帧空间初始化为0xCCCCCCCC)
    4. 出栈
      mov esp, ebp 使栈指针指向帧指针
      pop ebp 将调用者的帧指针的地址出栈, 此时ebp指向调用者的帧指针
      ret 将下一个指令的地址出栈并保存到pc寄存器中(eip)
    5. 结束
      (vs由于参数压栈, 还需要调整esp的位置)
      mov -12(%esp), %eax 将返回的结果赋值

  [返回值的返回方式]:
    1. 当返回值的大小不超过4字节时, 通过eax寄存器返回
    2. 当返回值的大小大于4字节不超过8字节时, 联合eax与edx寄存器返回
    3. 当返回值的大小超过8字节时, 需要在调用者栈帧中开辟一段临时空间,
    在被调用者栈帧中将数据拷贝到临时空间, 并将该临时空间的地址通过eax返回,
    然后调用者将eax指向的临时空间的数据再拷贝到指定接收对象中


  [数组]:
    数组其实就是在内存中开辟的一段连续的内存空间, cpu通过常见的地址操作Imm(Eb,Ei,s)来完成对数组的操作
    多维数组(二维数组)可以看作嵌套的一维数组:
      比如说arr[M][N]: 其实就是M个arr[N], 在内存中本质上是一维数组, 优先按行存取:
      //int arr[M][N];
      //int* p = (int*)arr;
      //p[i] 来访问
    [地址操作代替整数乘法]:
      在较早的IA32指令系统中, 整数乘法指令需要30个生命周期, 效率低下, 因此编译器尽量优化避免
      但是目前的处理器模型中, 整数乘法指令只需要3个生命周期, 因此编译器不一定对此操作进行优化
    [顺序访问优化]:
      一般在遍历数组或对固定大小数组进行操作时, 编译器会将操作的元素看作地址相邻的数据
      然后通过指针的偏移(地址操作)+存取寄存器来实现

