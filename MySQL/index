MySQL在磁盘上的存储: 表结构+表数据+索引

(B+树索引)
[MyISAM与InnoDB的区别]:
1. 底层结构不同
MyISAM: 数据和索引分开存放, 非聚集索引
比如说创建一个user表, 会产生3个文件, 分别是表结构文件, 表数据文件, 表索引文件
InnoDB: 数据和索引一起存放, 聚集索引
比如说创建一个user表, 会产生2个文件, 分别是表结构文件, 索引数据文件
由于InnoDB, 数据必须要按照主键来进行存储, 因此创建的表中必须要有主键,
如果用户没有定义, 那么InnoDB会指定一个唯一子段或生成一个唯一子段来作为主键索引(long int)
2. 支持功能不同, InnoDB支持事务和行级锁, 但是MyISAM不支持
InnoDB支持外键, MyISAM不支持
3. 在MySQL中默认是InnoDB存储引擎, 因为他支持事务和行级锁,
适合多读多写, 高并发的场景


Memory: (哈希索引)

[查看SQL的执行计划]:
explain + SQL
通过查看SQL的执行计划, 来查看该SQL语句使用索引的情况

[索引]: 主键索引+辅助索引
创建单列索引:
create index name_idx on user(name);
创建多列索引:(只有当多列索引所涉及的字段全部出现的时候, 多列索引才起效果)
create index name_age_idx on user(name, age); (涉及filesort也需要为排序字段创建索引)
删除索引:
drop index name_idx on user;

[索引的优化规则]:
1. 对where条件中区分度高的字段加索引
2. 使用联合索引时, 由于叶子节点的存储顺序是按照联合索引的顺序存储的,
因此将区分度高的字段放在左边
比如说where id = 1 order by age, 将id放到左边, 再进行查询时将满足id=1找到后, age已经排好序了
3. 多表查询时, 先判断大小表, 哪个表开销小哪个就是小表, 从小表中取出所有符合条件的,
在大表中循环查找
小表决定循环的次数, 大表决定每次循环的时间.
因此一般要根据大表来加索引
4. 索引不能太多, 因为对于1张表的查询, 只能用到1个索引, 如果索引多了,
会影响索引的选择, 也可以使用force index来强制索引
