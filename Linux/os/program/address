寻址模式: 实地址模式, 保护模式

[实地址模式]:
  8086CPU的位数是16位(ALU的宽度), 而地址总线的宽度是20位, CPU不能完全访问
  这1M的内存, 因此需要通过MMU来实现逻辑地址到线性地址的转换

  通过基址寄存器来实现高地址访问
  基址寄存器: CS(指令基址寄存器), DS(数据基址寄存器), SS(堆栈基址寄存器), ES(其他)

  [逻辑地址到线性地址的转换:]
  **基地址(基址寄存器<<4) + 逻辑地址(高12位) = 线性地址

  20位基地址的高16位与16位逻辑地址的高12位相加=线性地址(低4位是保留位)

  缺陷: 缺少内存保护的机制, 直接通过修改基址寄存器来访问到内存中的任意单元, 不能
  控制一个进程的内存访问权限和限制, 谈不上内存管理

[保护模式]:
  80386CPU的位数是32位, 地址总线的宽度也是32位, CPU可以完全访问4G的内存, 但是为了
  兼容之前的MMU内存管理的模式(基址寄存器的提出), 依然需要进行逻辑地址到线性地址的转换

  增加了2个寄存器来实现保护模式.
  FS/GS

  这两个寄存器中存放的是段描述符表的地址, 段描述符表中的表项记录了基地址, 地址长度, 
  访问权限等信息. 用户只能通过基址寄存器的高13位作为下标来访问指定的表项信息, 无法直接
  修改基址寄存器来随意访问内存
  但其实这只是为了兼容8086的内存管理模式, MMU经过一系列的转换过后, 基地址的值为0,
  也就是说逻辑地址 = 线性地址

  [逻辑地址到线性地址的转换]:
  将16位基址寄存器分成3段:
  低2位: 代表特权级别(内核(00)/用户(11))
  第3位: 段描述符表指针, 0使用GDTR, 1使用LDTR
  高13位: 段描述符表下标, 访问对应的表项(基地址, 段长度...)

  **基地址(0) + 逻辑地址 = 线性地址

  [线性地址到物理地址的转换]:
  将32位的线性地址分成3段:
  (cr3为页目录表基址寄存器)
  高10位: 代表页目录表下标, 每个页目录表表项指向一个页表
  中间10位: 代表页表下标, 每个页表表项指向一个物理页
  低12位: 代表物理页的偏移量, 找到实际物理地址的位置

  页目录表为一个, 大小为4k, 每个表项为4字节
  页表有多个, 每个大小为4k, 每个表项为4字节
  物理页有多个, 每个大小为4k, 地址偏移从0~4095字节

  总结: 线性地址到物理地址的转换, 在x86上需要进行2级映射
  先通过线性地址的高10位作为页目录表的下标, 找到对应的页表
  再通过中间10位作为页表的下标, 找到对应的物理页
  最后通过低12位作为物理页表的偏移量, 找到实际的物理地址

    [为什么要进行2级映射, 而不是1级]:
    一级映射是指, 只维持一张页表, 页表的表项映射到物理页.
    物理内存的大小为4G, 每个物理页是4k, 那么需要2^20个物理页
    因此页表需要有2^20个表项, 每个表项4字节, 则页表大小为4M.
    每个进程无论如何都需要维持一张4M的页表, 而实际使用的物理内存
    却很少, 这样就造成了内存的浪费, 因此采用多级映射, 按需分配页表

  [内核是如何描述和组织管理内存的]:
  进程PCB中的mm描述了进程地址信息, mm_struct* mm
  mm_struct中的mmap描述了进程虚拟地址空间的使用情况, vm_area_struct* mmap(是一个链表结构)
    mmap中的vm_start描述了线性区域的起始位置
    mmap中的vm_end描述了线性区域的结束位置
    mmap中的next指向了下一个线性区域
  mm_struct中的pgd描述了页目录表, 组织进程线性地址到物理地址的转换
