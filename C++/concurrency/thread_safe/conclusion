[线程之间共享数据]:
  [用互斥元保护共享数据]:
    可以通过加锁和解锁操作来实现互斥, 从而实现保护共享数据

    互斥用互斥锁时会存在一些安全问题:
    1. 保护数据的传出. 比如说保护数据在脱离保护域到非线程安全的作用域内
      可以通过避免将保护数据的指针或引用传出保护域
    2. 异常中断. 比如说保护域内的数据在返回之前被异常中断
      可以通过RAII来管理有返回值的数据
    3. 死锁. 多个线程因为竞争资源而导致推进顺序不当造成的阻塞现象
      比如说甲拿着A锁请求B锁, 乙拿着B锁请求A锁, 并且手里的锁都不释放, 造成死锁
      死锁还有一种情况是线程的相互等待, 造成阻塞
      
      避免死锁的方式:
      1. 避免嵌套锁 --- 简单粗暴
      2. 通过RAII以固定顺序获取和管理锁 --- lock+lock_guard/unique_lock
      3. 使用锁层次(类似于2中顺序锁) --- 封装一个分层互斥锁

    4. 锁粒度的控制. 持有锁的时间过长会导致性能下降
      对锁粒度的控制, 要考虑锁的持有时间以及持有锁时的做了哪些操作

  [共享数据初始化]:
    共享数据在初始化的时候会考虑到数据竞争的线程安全的问题
    但是所有线程如果都需要对数据进行初始化或者判断数据是否初始化会付出较大的代价

    可以通过只进行一次共享数据的初始化来解决:
      比如说延迟初始化机制

  [读写锁]:
    在大多数情景下, 对于共享数据的操作, 一般是偶尔写和频繁读的场景居多, 只有写操作
    是互斥的, 而读操作可以同步进行. 但是在C++11中没有实现读写锁. 可以通过boost库来实现.
    比如说:(大家可以同时读, 但是有一个线程写, 其他线程既不能读也不能写)
    加读锁: boost::shared_lock<boost::shared_mutex> lk(_mutex);
    加写锁: std::lock_guard<boost::shared_mutex> lk(_mutex);
      
  [递归锁]:(从设计层面来避免)
    对持有的锁再次加锁: 比如说一个类中的成员函数中加锁后再调用另一个有加锁操作的函数
    使用mutex会产生未定义行为
    可以通过使用std::lock_guard<std::recursive_mutex>
    但是这种类的设计是不合理的(嵌套会导致更多的阻塞)
    一般不推荐使用递归锁, 可以重新写一个不加锁的私有函数来解决

