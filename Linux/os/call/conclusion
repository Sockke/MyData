[函数调用的过程]:
1. 对参数进行一个保存, 将参数压栈
(gcc对于一些占用字节比较小的参数会保存在被调用者寄存器中)
2. call
push eip   ---   保存下一条指令
mov $0x5631076 eip   ---   调用该函数

3. push
push ebp  ---   保存调用者的帧指针
mov esp, ebp  ---   使帧指针指向栈指针
sub $0x20, esp  ---   栈帧开辟

4. pop(leave)
mov ebp, esp  ---   使栈指针指向帧指针, 进行栈帧回退
pop ebp  ---   将调用者的帧指针出栈

5. ret 
pop eip  ---   将下一条指令放到pc寄存器中(eip)

6. 返回调用结果(对于小于8个字节的放到寄存器, 大于8个字节的放到栈中)

[系统调用与库函数的区别]:
1. 系统调用是内核为应用程序提供的接口, 是系统级别的.
而库函数是为了方便用户编程, 提供的一些功能接口, 这些接口有些是对系统调用的封装, 是用户级别的.
2. 系统调用会产生0x80号中断, 从用户态切换到内核态, 然后根据系统调用号进行查表, 执行指定的系统调用,
完成后需要从内核态切换到用户态, 将结果返回
而库函数, 有些是对系统调用的封装, 比如说printf, 底层是对write系统调用的封装, 有些根本没有
进行系统调用, 比如说strlen, strcpy等.
3. 库函数在用户态实现了缓冲区, 因此对于一些封装了系统调用的库函数来说, 
大大减少了系统调用的次数, 减少了内核态与用户态切换带来的开销
