[Linux虚拟存储器系统]

  [描述]:
    虚拟存储器是进程的一部分, task_struct中的mm指向的mm_struct描述了
    当前虚拟存储器的状态, 其中pgd指向了页表基址, mmap指向了区域链表
    (目测是红黑树结构), vm_area_struct描述了当前进程地址空间的一段区域

  [Linux缺页异常的处理]:
    Linux缺页异常的处理分为3种情况
    1. 正常缺页
      对合法的虚拟地址进行操作; 如果内存空间充足, 找到一个合适的物理页, 
      根据虚拟内存区域与可执行文件的映射关系, 通过偏移找到指定数据的位置,
      然后建立物理页与虚拟内存区域的映射, 最后回到产生缺页指令的位置重新执行.
      否则, 选择合适的牺牲页, 进行暂时性的回收, 在Linux上就是暂时放到swap分区,
      然后重新建立该虚拟内存区域与物理页的映射, 这可以称作页面的调度.
      频繁的页面调度会影响整个程序的性能
    2. 段错误
      对不存在的虚拟地址进行操作; 该虚拟地址不能与vm_area_struct进行匹配,
      会触发一个段错误, 内核会终止进程
    3. 保护异常
      对不合法的虚拟地址进行操作; 如果该虚拟地址对应的区域没有指定的操作
      权限(比如说读写权限), 会触发一个保护异常, 内核会终止进程

[存储器映射]:
  存储器映射就是将虚拟存储器区域与磁盘上的对象关联起来的过程
  虚拟存储器区域可以映射两种类型的对象:
  1. 普通文件
    磁盘上的普通文件
  2. 匿名文件
    内核创建的二进制文件
  无论哪种情况, 一旦虚拟页面被初始化了, 它就会在内核维护的交换文件(交换空间)
  之间换来换去, 交换空间就是在内存不够用时用来暂时存储虚拟页面的空间. 
  交换空间限制着当前进程所能创建的虚拟页面的总数(一般交换空间的大小是内存的2倍)

  [共享对象与私有对象]:
    共享对象: 多个进程映射同一块物理内存, 共享一份拷贝对象, 比如说共享库
    私有对象: 写时拷贝技术, 多个进程先映射同一块物理内存, 但是页面权限为只读,
    当某个进程的数据发生改变时, 会触发一个保护异常, 内核为该进程创建单独的页面拷贝, 
    并更新页表条目, 然后修改页面权限为可写


[fork]:
  调用fork函数, 内核会为新进程创建各种数据结构, PID, 以及虚拟存储器等. 虚拟存储器
  标记两个两个页面为只读...(写时拷贝技术)
[execve]:
  调用execve函数一般经历3个重要的步骤
  1. 删除已存在的用户区域结构
  2. 重新映射共享区和私有区
  3. 设置程序计数器, 使之指向文本区域入口点
  此时被调度的进程就从这个入口点开始执行
[mmap]:
  调用mmap, 完成用户级虚拟存储器映射
  void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
  addr: 虚拟存储器区域的起始位置, 一般设置为NULL
  length: 区域大小
  prot: 读写权限
  flags: 共享, 私有等属性
  fd: 文件描述符指定需要映射的磁盘对象
  offset: 据文件起始处的偏移量

  int munmap(void *addr, size_t length);
  删除从addr起始处的length长度的映射区域

