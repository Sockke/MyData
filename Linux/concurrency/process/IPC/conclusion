[进程间通信]: 
  进程间不能直接通信: 进程之间是相互独立的, 有各自的进程地址空间
  进程间通信的方式: 管道, 共享内存, 消息队列, 信号量, socket套接字(应用场景不同) 

  [管道]:
    管道的本质就是操作系统在内核中创建的一块缓冲区
    管道的特性:
    1. 通信方式: 半双工通信 
    2. 传输方式: 面向字节流
    3. 通信安全: 管道自带同步与互斥, 实现了通信安全与合理
      读写特性: 读写特性(命名管道的打开特性)
      1. 阻塞: 管道中没有数据则read阻塞, 管道中数据已满则write阻塞
      2. 关闭读写: 所有写端关闭则read返回0, 所有读端关闭则write触发异常

    [匿名管道]: 没有名字标识的管道
    只能用于具有亲缘关系的进程之间通信: 因为子进程复制父进程的文件描述符表, 
    子进程可以共享父进程创建的匿名管道, 从而实现通信
    int pipe(int pipefd[2])
      pipefd[2]: 管道描述符表
        pipe[0]: 用于从管道中读取数据
        pipe[1]: 用于向管道中写入数据
      成功返回0, 失败返回-1

    [命名管道]: 有名字标识的管道, 实际上通过一个文件来访问管道
    可以用于任意进程之间通信, 只要通过访问同一个管道文件即可
    int mkfifo(const char* filename, mode_t mode)
      filename: 管道文件名
      mode: 文件权限(基于权限掩码: mode&~umask)

    打开特性: 阻塞
    文件的读写端都开启后才能进行通信, 否则阻塞
    1. 管道文件只被读打开, 会阻塞
    2. 管道文件只被写打开, 会阻塞
    
  

  [共享内存]:
    共享内存的本质就是物理内存中开辟的一块共享区域
    共享内存的特性: 
    1. 通信方式: 全双工, 既可以对该共享内存读, 也可以写
    2. 通信流程: 共享内存创建好后, 进程之间可以通过对共享内存的操作来实现通信
    没有了用户态与内核态的转换, 同时也减少了数据的拷贝

    [共享内存工作流程]:
    1. 在物理内存中开辟一块共享内存
    int shmget(key_t key, size_t size, int shmflg);
      int shmid = shmget(0x12345678, 4096, SHM_CREAT | 0664)
      key: 共享内存的标识
      size: 共享内存的大小
      shmflg: 共享内存的开辟方式
      返回值: 共享内存的操作句柄
    2. 将这块共享内存映射到不同进程的地址空间中去
    void *shmat(int shmid, const void *shmaddr, int shmflg);
      void* shm_start = shmat(shmid, NULL, 0)    
      shmid: 共享内存描述符
      shmaddr: 进程地址空间的映射起始地址
      shmflg: 操作权限, 0为可读可写
      返回值: 映射后共享内存的起始地址
    3. 进程之间可以通过操作共享内存来实现通信
    memcpy...
    4. 解除进程与共享内存的映射关系
    int shmdt(const void *shmaddr);
      shmdt(shm_start)
    4. 删除共享内存
    int shmctl(int shmid, int cmd, struct shmid_ds *buf);
      shmctl(shmid, SHM_RMID, NULL)
      cmd: 共享内存的控制方式, SHM_RMID为删除
      buf: 共享内存的状态信息

[消息队列]:
  本质上是内核中的一个优先级队列, 多个进程通过访问同一个队列来实现通信

  消息队列有队头和队尾的指针来进行组织 
  1. 当msgsnd数据时, 数据块会被连接到队尾;
  2. 当msgrcv数据时, 会从队头开始, 判断第一个符合mtype的数据, 将数据块取出

  [消息队列的函数]:
    int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
      msqid: 消息队列的操作句柄
      msgp: 消息队列数据结构体
        msgp->mtype: 数据类型
        msgp->mtext: 数据内容
      msgflg:
    ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);
      msqid: 消息队列的操作句柄
      msgp: 接收的数据
      msgsz: 接收的数据大小
      msgtyp: 接收方式, 控制优先级
        0:第一个消息 
        >0:接收类型为mtype的第一个数据 
        <0:接收类型小于等于|msgtyp|的第一个消息

  [消息队列的应用]:
    1. 通过异步处理提高系统性能. 
    比如说在应用服务器与数据库服务器之间加一个消息队列,这样可以使用户发送的请求
    不直接写入数据库, 而是发送给消息队列直接返回(消息队列的处理速度要比数据库快) 
    也就是说通过异步处理, 将高并发产生的事务消息存储在消息队列中, 从而减少数据库
    服务器的压力, 提高响应速度
    2. 分布式转发降低系统耦合性.
    比如说消息队列可以采用发布-订阅模式工作, 生产者发布消息到消息队列中, 
    消费者从消息队列中订阅消息, 但是生产者与消费者之间没有直接耦合

  [消息队列的缺点]: 复杂
    使用消息队列要考虑消息有没有被重复消费, 消息有没有丢失, 消息有没有
    被正确消费, 消息被消费的顺序...

[信号量]: system-V标准
  本质上是内核中的一个计数器+等待队列
  计数器: 资源计数, 统计有多少资源, 判断是否能进行操作
  主要用于实现进程间的同步

  [信号量流程]: PV原语
  1. 消费资源, 在操作之前先判断信号量计数, 若<=0则等待, 若>0则直接返回开始消费, 计数-1
  2. 生产资源, 计数+1, 并唤醒指定等待队列上的进程


[ipcs]:
  ipcs: 查看IPC
    ipcs -m (查看共享内存)
    ipcs -s (查看信号量)
    ipcs -q (查看消息队列)
  ipcrm 删除IPC
    ipcs -m/-s/-q id

