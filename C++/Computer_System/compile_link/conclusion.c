//编译链接原理
[生成可执行文件的过程]:
  预编译->编译->汇编->链接 

  [链接]: ld -e main *.o   ---    ld链接器, -e指定入口函数
  1. 合并.o文件的各个段
    将所有的.o文件的相应段合并 
    readelf -S main.o // 查看.o文件的所有段.text, .data, .bss, .symbal

  2. 符号解析
    根据符号的引用在各个.o段中寻找唯一的符号定义
    找不到则产生未定义行为, 找到多个则产生重定义行为
    objdump -s main.o // 查看.o文件的符号表信息
  3. 符号重定位(链接时的重定位)
    合并所有的.o段, 并为符号分配虚拟地址


  .o文件与.elf文件的区别:
  1. 类型不同, .o是可重定位文件, .elf是可执行文件
  2. elf头信息不同, .elf文件比.o文件多了一段program headers
  program headers: 告诉操作系统, 运行这个程序的时候, 需要把哪些内容加载到内存中去
  readelf -l main   -->  .text .data .bss 段映射到虚拟地址空间中

  [装载]:
  1. 为进程创建虚拟地址空间. 就是在pcb中创建相应的虚拟内存区域的数据结构
  2. 建立虚拟地址空间与可执行文件的映射.
  读取ELF文件头, 将可执行文件中的各个段与指定的虚拟内存区域建立映射关系
  3. 将cpu指令寄存器设置成可执行文件的入口.
  就是在ELF头中保存的入口地址保存到寄存器中, 然后将可以行的权限转交给进程, 启动执行

  1. 符号的解析规则?
  gcc:
    在gcc中, 默认符号解析规则中, 出现多重定义符号时, 可能不会报错
    不能存在多个同名的强符号
    当存在一个强符号, 一个弱符号时, 使用强符号
    当存在多个弱符号时, 使用任意一个弱符号
    (强符号: 全局的初始化变量; 弱符号: 全局的未初始化变量) 
  g++:
    在g++中, 默认调用了 -fno-common 选项来告诉链接器, 只要出现多重定义的符号, 就报错

  2. 静态库与动态库的连接过程?
    静态链接: 
      编译时期, 为在头文件中使用的函数声明生成符号表.
      链接时期, 符号解析, 为每个符号的引用在各个.o段中关联唯一的符号定义;
      重定位, 合并各个.o段并为符号分配虚拟地址
    动态链接: 
      编译时期, 为在头文件中使用的函数声明生成符号表
      链接时期, 符号解析, 根据符号引用在各个.o段中关联唯一的符号定义;
      重定位, 不合并动态库中的.o段, 将.o段的符号记录在符号表中, 分配相对地址
      装载时期, 在确定了目标地址后, 根据动态库指定段中的相对地址, 分配最终的虚拟地址
      (装载时期的重定位)

    因为动态库是多个进程共享的, 因此共享库在共享内存中会有指定的地址, 
    如果为共享库分配一个绝对地址, 那么当加载的动态库发生变化比如说增多或减少, 
    会影响共享内存的使用效率, 或者产生内存重叠的情况. 
    通过为共享库分配相对地址, 使动态库能够在共享内存的任意位置进行加载,
    使得在共享内存中根据情况为动态库, 更合理的分配空间不会造成内存重叠的情况.
    
  3. 静态链接与动态链接的分析 
  静态链接:
    优点:
    1. 运行速度快
    2. 程序的可移植性强
    缺点:
    1. 内存的浪费
    2. 更新和发布困难
  动态链接:
    优点:
    1. 节省内存, 多个程序共享动态库
    2. 更新和发布简单, 只需要覆盖旧的动态库即可, 不需要重新链接
    3. 可扩展性和兼容性强, 扩展动态库和发布兼容性动态库方便, 只需要程序运行时加载即可
    缺点:
    1. 运行速度不如静态链接, 因为运行过程中需要加载动态库
    2. 程序本身的可移植性不如静态链接的程序, 需要依赖动态库

