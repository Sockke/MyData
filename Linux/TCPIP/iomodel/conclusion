[select]:
  采用事件集合的形式来组织事件, 底层是一个位图, 每种类型事件对应一个集合
  1. 创建事件集合, 并初始化
  2. 将用户关心的事件描述符添加到集合当中
  3. 调用select开始监听
  将整个事件集合拷贝到内核中, 在内核中轮询遍历集合中的事件, 
  就绪的事件置1, 位就绪的事件置0, 然后将就绪事件集合拷贝到用户态,
  遍历整个就绪集合, 对就绪的事件进行处理

[poll]:
  采用事件结构的形式来组织事件, 统一了事件的处理
  1. 创建事件结构体数组.
  2. 将用户关心的事件结构添加到事件结构数组中
  3. 调用poll开始监听.
  将整个事件结构拷贝到内核中, 在内核中轮询遍历数组中的事件结构,
  当有事件就绪时, 将就绪的事件的revent进行一个标记, 然后将整个事件结构数组拷贝到用户态,
  遍历整个事件结构数组, 判断revent, 对就绪事件进行处理

[epoll]:
  采用事件结构的形式来组织事件, 统一了事件的处理.
  在内核中会创建一个eventpoll, 通过红黑树来存储关心事件, 双向链表来存储就绪事件
  1. 在内核中创建一个eventpoll结构体, 用来组织事件
  2. 将用户关心的事件添加到eventpoll中的红黑树中
  3. 调用epoll_wait开始监听.
  将用户关心的事件结构拷贝到内核中, 将事件挂在eventpoll中的红黑树中, 
  当有事件到来时, 会调用事件回调函数, 将就绪事件添加到就绪链表中,
  内核通过判断就绪链表是否为空, 如果不为空, 则将就绪事件通过共享内存的形式
  返回给用户进行处理

[select的缺陷]
1. select每次都需要将事件集合拷贝到内核, 将就绪事件集合拷贝到用户态,
频繁的内核态与用户态的切换消耗很大
2. select监控采用轮询遍历的方式, 性能会随着事件描述符的增多而下降
3. select返回给用户的是整个事件集合, 用户还需要轮询遍历, 对就绪的事件进行操作
4. select采用事件集合的方式, 每种事件对应一种集合, 事件处理不统一,
并且事件描述符的数量有限制1024

[poll的缺陷]:
与select的一样, 唯一一点优势在于,
poll采用事件结构的形式, 统一了事件的处理, 对于事件描述符资源没有限制

[epoll的优势]:
1. epoll每次只需要将关心的事件结构拷贝到内核的红黑树中, 就绪的事件会放到内核的
双向链表中, 通过共享内存映射到用户态, 少了一次内核到用户态的数据拷贝
2. epoll不采用轮询遍历的方式监听, 而是采用回调函数, 当事件就绪时会自动调用
回调函数, 添加到就绪链表中, 性能不会随事件描述符的增多而下降.
3. epoll返回给用户的是都是就绪的事件, 用户不需要遍历判断, 直接可以进行操作
