// sizeof(*p) 与 sizeof(b)

#include <iostream>
using namespace std;

// 指针与引用的区别:
// 定义指针变量和引用变量在汇编层面是一样的, 
// 通过指针解引用修改变量和通过引用修改变量的汇编层面也是一样的
//
// 1. 指针不用初始化, 引用必须初始化, 必须指向一段内存
// 2. 指针有多级指针, 引用没有多级引用
// 3. 引用更加安全

// 左值引用与右值引用:
// 左值: 有内存, 有名字, 值可以修改(编译器将左值看作地址)
// 右值: 没内存(立即数在寄存器中), 没名字(编译器将右值看作内容)
//
// 左值引用: 用来引用左值, 在汇编层面上与定义指针变量是一样的, 将左值的地址放到eax寄存器中,
// 再把eax寄存器中的地址放到引用的内存中
//
// 右值引用: 用来引用右值, 在汇编层面上, 会自动产生一个临时量来存储右值, 右值存放到栈中的内存中,
// 将该临时量的地址放到eax寄存器中, 最后将eax寄存器中的地址放到右值引用变量引用的内存中
// 因此右值引用变量本身是左值, 所以只能通过左值来引用右值引用变量

// 带左值的拷贝构造和赋值与带右值的拷贝构造和赋值的区别?
// 1. 同作用域对象进行拷贝构造和赋值操作, 匹配左值引用参数的拷贝构造函数和赋值重载函数
// 需要重新开辟内存空间, 拷贝数据. 对于赋值重载还需要先释放原来占用的资源.
// 2. 用临时对象或局部对象给新对象拷贝和赋值时, 匹配的是右值引用参数的拷贝构造
// 或赋值重载函数, 直接把临时对象或局部对象的资源直接转移给目标对象,
// 不做任何的内存开辟和释放, 以及对象构造析构操作.

#if 0
int main() {
  int num = 10;
  /*
  lea eax, num
  mov ptr[a], eax
  */
  int& a = num;
  /*
  mov ptr[tmp], 0xA
  lea eax, ptr[num]
  mov ptr[b], eax
  */
  int&& b = 10;
  /*
  const int& 与 int&& 引用变量在汇编层面是一样的, 都需要产生临时量
  mov ptr[tmp], 0xA
  lea eax, ptr[tmp]
  mov ptr[c], eax
  */
  const int& c = 10;
  return 0;
}
#endif

#if 0
int main() {
  // 错误的, 把引用先转换成指针再进行判断
  int a = 10;
  int* p = &a;
  //const int*& q = p;
  //const int** q = &p;
  return 0;
}
#endif
