[TCP数据报信息]:
  报头:
  1. 16位源/目的端口号: 描述数据从哪个进程来, 到哪个进程去
  2. 32位序号/确认序号:
    序号用来描述该数据包在原数据中的第几个字节
    确认序号用来告诉发送端需要发送的序号
  3. 4位首部长度(单位为4个字节): 描述报头长度, 报头的大小最小为20字节, 最大为60字节
     6位保留位, 6位状态码: 描述当前有效状态
      SYN(请求连接), ACK(响应确认), FIN(结束连接), RST(重新连接)
      PSH(要求从缓冲区读走数据), URG(紧急指针)
     16位窗口大小: 描述收发缓冲区当前大小, 发送缓冲区大小依赖于对端接收缓冲区的大小
  4. 16位校验和: 描述数据是否正确传输(二进制反码求和算法), 检验数据的一致性
     16位紧急指针: 用于描述紧急数据(优先发送)
  5. 40字节选项
  报文:
  1. 数据

[TCP特性]:
  面向连接, 可靠传输, 面向字节流

  [面向连接]:
    客户端在与服务端进行通信之前需要建立连接(三次握手), 结束通信需要关闭连接(四次挥手)
    [建立连接和释放连接的过程]:
    1. 客户端向服务端发起连接请求, 客户端发送SYN请求, 进入SYN-SENT状态,
    服务端收到后发送SYN ACK回复, 进入SYN-RCVD状态, 表示服务端已经正确接收,
    最后客户端发送ACK回复, 进入ESTABLISHED状态, 服务端接收到后也进入ESTABLISHED状态,
    此时两端可以进行数据通信了.
    2. 客户端向服务器发起释放连接请求, 客户端发送FIN请求, 进入FIN-WAIT1状态,
    服务端收到后发送ACK响应, 进入CLOSE_WAIT状态, 表示已经接收到客户端的请求了,
    客户端接收到服务端的ACK响应后, 进入FIN-WAIT2状态.
    当服务端将数据发送完毕之后, 发送FIN ACK请求, 进入LAST-ACK状态, 表示服务端准备好释放连接了,
    客户端收到后发送ACK响应, 进入TIME-WAIT状态, 保证服务端能正常释放连接.

    [为什么是三次握手而不是两次握手]:
    1. 无论三次握手还是四次挥手, 双方必须要保证连接是全双工的
    2. 三次握手, 是为了协商好双方序列号的初始值以及收发窗口的大小,
    保证客户端与服务端能够正常收发数据
    3. 如果是2次握手, 服务端在响应ACK, SYN包之后, 就会认为已经建立好连接了,
    此时只协商好了客户端的初始序列号, 没有协商好服务端的初始序列号, 
    并且响应包可能在网络中丢失了,客户端并没有收到服务端响应包, 会认为没有建立连接, 
    那么服务端发送数据, 客户端不接收数据, 会造成死锁现象.
    [为什么不是四次握手]:
    1. 三次握手就能保证连接是全双工的
    2. 三次握手已经能够协商双方序列号的初始值, 以及收发窗口的大小
    3. 四次握手没有必要
    [为什么不是三次挥手]:
    1. 无论是三次握手, 还是四次挥手, 都要保证连接是全双工的
    2. 四次挥手是为了保证服务端数据的正常发送
    3. 如果是三次挥手, 服务端需要同时响应ACK FIN包, 
    此时如果服务端还有数据没有发完, 就不能在正常发送了 
    因此必须要使服务端的ACK响应和FIN请求分开, 
    服务端发送ACK响应表示我已经收到你的请求了, 服务端在保证数据发送完毕之后,
    再发送FIN告诉客户端, 我准备好释放连接了
    [为什么握手是三次, 挥手是四次呢]:
    1. 无论是三次握手, 还是四次挥手, 都是要保证连接是全双工的
    2. 三次握手是建立连接的过程, 这个过程还没有数据的数据的收发,
    因此服务端可以同时发送ACK SYN包进行响应和请求.
    而四次握手这个过程中还有数据的收发,
    服务端不能同时发送ACK FIN包进行响应和请求, 这样会导致服务端数据不能正常发送完毕,
    因此只能分开发送, 先发送ACK响应表示我收到了, 然后数据发送完毕之后,
    再发送FIN请求表示我准备好释放连接了

    [TIME-WAIT的作用]:
    1. 客户端在发送最后一个ACK之后进入TIME-WAIT状态, 
    主要是为了保证服务端能够正常接收到回复, 然后释放连接.
    2. 防止旧的报文对新连接造成影响, 如果说客户端最后一次ack由于网络延迟或路由转发时间过长, 
    出现了超时现象, 客户端重新发送ack, 重新发送的ack对端接收到了, 但是旧的ack还没被丢弃,
    如果time_wait时间过短, 其他的新连接也使用当前这个端口, 可能会收到上一个连接的旧的ack, 影响新连接

    [SYN泛洪攻击]:
    将源地址伪装成不存在的地址, 向服务端发起大量连接, 
    使服务端的大量连接处于SYN-RCVD状态, 资源耗尽导致服务端瘫痪
    还有将源地址伪装成目的地址向服务端发起大量连接,
    使服务端不断向自己发起连接请求, 资源耗尽导致服务端瘫痪
    1. 可以缩短SYN的超时时间, 如果接收不到ACK响应直接释放半连接
    2. 或者采用SYN cookie, 如果短时间内连续收到某个IP的重复SYN请求, 
    会被认为是收到了该IP的攻击, 直接丢弃IP发来的任何请求
    3. 防火墙
      
  [可靠传输]:
  应答机制+重传机制+包序管理机制     (还有面向连接, 校验和)
  1. 应答机制: 保证请求被收到, 并得到响应.
    比如说累计应答, 捎带应答
  2. 重传机制: 保证数据安全到达. 数据长时间没有接收到, 会请求重传
    比如说超时重传, 快速重传
  3. 包序管理机制: 保证数据有序到达. 双方协商序号和确认序号保证数据能够有序
    序列号代表这部分数据在原数据中的第几个字节

  3. 面向字节流
    TCP数据传输涉及到依赖收发缓冲区的概念. TCP与UDP不同的是, 发送数据首先先发到发送缓冲区,
    等到数据达到一定大小, 一并发送到对端的接收缓冲区, 这是按字节流进行发送.
    由于TCP在数据传输时, 对数据边界要求不明显, 会导致TCP粘包问题
    [如何解决TCP粘包]: 在应用层明确边界
    1. 特殊字符标记结尾. 比如说'\0'
    2. 定长发送和接收. 数据不足进行补全
    3. 每条数据封装头部并定义数据长度. 这种方式更可靠(类似于UDP)

[提高TCP性能]:
  流水线机制 + 滑动窗口机制
  1. 流水线机制:
  发送端可以连续发送多个数据包, 接收端这边可以进行累积应答,
  如果多个数据包中有中间数据丢失或延迟, 接收端可以进行快速重传,
  来让发送端重传指定序号的数据
  2. 滑动窗口机制:
  滑动窗口用来表示双方同时最多能收发多少数据. 
  在建立连接时协商好, 发送端要与接收端的窗口一样大.
  在收发数据的过程中, 发送端如果收到接收端的响应, 发送端根据响应的确认序号来移动窗口,
  接收端如果接收到数据后, 会根据接收数据的序号来移动窗口

  [累积应答]:
  又称为延迟应答, 发送端发送连续的数据包, 接收端不一个个的响应, 当接收了一些之后一块响应
  减少响应次数
  [捎带应答]:
  比如说在建立连接时, 客户端发送最后一次ACK时可以携带数据一块发送 
  减少一个空数据包的传输

  *[拥塞控制]:
  在两端维护一个拥塞窗口, 用来动态调整滑动窗口的大小, 取两者最小值, 来限制网络传输的吞吐量.
  1. 采用慢启动快增长的形式, 根据网络状况来调整窗口的大小, 防止因为网络状况不好
  而导致频繁的丢包现象
  2. 慢启动算法, 一开始先发送1个数据包, 然后以指数形式增长, 2, 4, 8...
  当增长到慢启动门限时, 改用拥塞避免算法, 慢启动门限默认是16
  3. 拥塞避免算法, 线性增长, 每次多发送1个数据包, 16, 17, 18...
  4. 如果在发送数据包的过程中出现了丢包现象, 说明网络出现拥塞,
  发送1个数据包, 执行慢启动算法, 并且满开始门限降为拥塞窗口的一半
  [快速重传]:
  发送端发送连续的数据包, 接收端在接收时发现有中间的数据包丢失或延迟到达
  则向发送端发送3次重传请求, 之所以发多次是为了检测网络状况调整拥塞窗口
  如果说网络状况没有出现拥塞, 那么启动快恢复算法, 直接在慢启动门限处执行拥塞避免算法
  保证了网络资源的利用率

[TCP异常]:
  进程终止或机器重启, 进程会释放所有的描述符
  如果网线断开或掉电等情况, TCP面对这种情况采用的是TCP保活机制(keepalive)
  它会定期询问对方是否还在, 如果对方始终不在, 才会释放连接
  默认: 通信双方如果7200s没有数据通信, 则每75s向对方发送保活探测数据报, 如果9次都没有响应
  则断开连接(sysctl -a | grep keepalive)
  比如说在程序中: recv返回0, send触发SIGPIPE异常

[TCP应用]:
  TCP主要用于安全性要求比较高的场景, 比如说文件传输
  基于TCP的协议: HTTP/HTTPS SSH FTP
